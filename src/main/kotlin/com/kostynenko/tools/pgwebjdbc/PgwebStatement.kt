package com.kostynenko.tools.pgwebjdbc

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import org.apache.logging.log4j.kotlin.logger
import java.sql.*


open class PgwebStatement(
    private val connection: PgwebConnection,
    private val jsonMapper: ObjectMapper
): Statement {
    private val logger = logger()
    
    private var rawResult: RawPgwebResult? = null
    private var isClosed = false
    private var isCloseOnCompletion = false
    private var poolable = false
    private var maxFieldSize = 0
    private var maxRows = 0
    private var fetchSize = 1000
    private var isResultTaken = false

    override fun executeQuery(sql: String): ResultSet {
        execute(sql)

        return requireNotNull(resultSet)
    }

    override fun executeUpdate(sql: String): Int {
        execute(sql)

        return getUpdateCount()
    }

    override fun close() {
        isClosed = true
    }

    override fun getMaxFieldSize(): Int = maxFieldSize

    override fun setMaxFieldSize(max: Int) {
        if (max < 0) {
            throw SQLException("The maximum field size must be a value greater than or equal to 0.")
        }

        maxFieldSize = max
    }

    override fun getMaxRows(): Int = maxRows

    override fun setMaxRows(max: Int) {
        if (max < 0) {
            throw SQLException("Maximum number of rows must be a value greater than or equal to 0.")
        }

        maxRows = max
    }

    override fun setEscapeProcessing(enable: Boolean) {
        logger.todo("PgwebStatement: setEscapeProcessing")
    }

    override fun getQueryTimeout(): Int {
        logger.todo("PgwebStatement: getQueryTimeout")
    }

    override fun setQueryTimeout(seconds: Int) {
        logger.todo("PgwebStatement: setQueryTimeout")
    }

    override fun cancel() {
        logger.debug("cancel")
        throw UnsupportedOperationException("Cancel not supported")
    }

    override fun getWarnings(): SQLWarning? {
        logger.todo("PgwebStatement: getWarnings")
    }

    override fun clearWarnings() {
        logger.todo("PgwebStatement: clearWarnings")
    }

    override fun setCursorName(name: String?) {
        logger.todo("PgwebStatement: setCursorName")
    }

    override fun execute(sql: String): Boolean {
        rawResult = jsonMapper.readValue<RawPgwebResult>(connection.nativeSQL(sql))

        return rawResult?.isResultSet() == true
    }

    override fun getResultSet(): ResultSet? {
        return if (isResultTaken) {
            null
        } else {
            rawResult.takeIf { it?.isResultSet() == true }?.let {
                isResultTaken = true
                PgwebResultSet(it)
            }
        }
    }

    override fun getUpdateCount(): Int {
        return if (isResultTaken || rawResult?.isUpdateCount() == false) {
            -1
        } else {
            isResultTaken = true
            rawResult?.updateCount() ?: -1
        }
    }

    override fun getMoreResults(): Boolean = false

    override fun setFetchDirection(direction: Int) {
        logger.todo("PgwebStatement: setFetchDirection")
    }

    override fun getFetchDirection(): Int {
        logger.todo("PgwebStatement: getFetchDirection")
    }

    override fun setFetchSize(rows: Int) {
        if (rows < 0) {
            throw SQLException("Fetch size must be a value greater than or equal to 0.")
        }

        fetchSize = rows
    }

    override fun getFetchSize(): Int = fetchSize

    override fun getResultSetConcurrency(): Int {
        logger.todo("PgwebStatement: getResultSetConcurrency")
    }

    override fun getResultSetType(): Int = ResultSet.TYPE_FORWARD_ONLY

    override fun addBatch(sql: String?) {
        logger.todo("PgwebStatement: addBatch")
    }

    override fun clearBatch() {
        logger.todo("PgwebStatement: clearBatch")
    }

    override fun executeBatch(): IntArray? {
        logger.todo("PgwebStatement: executeBatch")
    }

    override fun getConnection(): Connection = connection

    override fun getMoreResults(current: Int): Boolean = false

    override fun getGeneratedKeys(): ResultSet? {
        logger.todo("PgwebStatement: getGeneratedKeys")
    }

    override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int {
        logger.todo("PgwebStatement: executeUpdate")
    }

    override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int {
        logger.todo("PgwebStatement: executeUpdate")
    }

    override fun executeUpdate(sql: String?, columnNames: Array<out String?>?): Int {
        logger.todo("PgwebStatement: executeUpdate(sql: String?, columnNames: Array<out String?>?)")
    }

    override fun execute(sql: String?, autoGeneratedKeys: Int): Boolean {
        logger.todo("PgwebStatement: execute(sql: String?, autoGeneratedKeys: Int)")
    }

    override fun execute(sql: String?, columnIndexes: IntArray?): Boolean {
        logger.todo("PgwebStatement: execute(sql: String?, columnIndexes: IntArray?)")
    }

    override fun execute(sql: String?, columnNames: Array<out String?>?): Boolean {
        logger.todo("PgwebStatement: execute(sql: String?, columnNames: Array<out String?>?)")
    }

    override fun getResultSetHoldability(): Int {
        logger.todo("PgwebStatement: getResultSetHoldability")
    }

    override fun isClosed(): Boolean = isClosed

    override fun setPoolable(poolable: Boolean) {
        this.poolable = poolable
    }

    override fun isPoolable(): Boolean = poolable

    override fun closeOnCompletion() {
        isCloseOnCompletion = true
    }

    override fun isCloseOnCompletion(): Boolean = isCloseOnCompletion

    override fun <T : Any> unwrap(iface: Class<T>): T {
        if (iface.isAssignableFrom(javaClass)) {
            return iface.cast(this)
        }

        throw SQLException("Cannot unwrap to " + iface.getName());
    }

    override fun isWrapperFor(iface: Class<*>): Boolean = iface.isAssignableFrom(javaClass)
}
